{"version":3,"sources":["index.js","appState.js","bindParams.js","provide.js","pureStoreMixin.js","reference.js","stateBindings.js"],"names":[],"mappings":"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","file":"purereflux.js","sourcesContent":["import { state, clearState, getCurrentState, getState } from './src/appState'\nimport PureStoreMixin from './src/pureStoreMixin'\nimport stateBindings from './src/stateBindings'\nimport provide from './src/provide'\nimport bindParams from './src/bindParams'\n\nexport { PureStoreMixin, provide, bindParams, stateBindings, clearState, getCurrentState, getState }","import immstruct from 'immstruct'\n\n// This is the global application state\nlet state = immstruct({});\n\nexport function clearState() {\n\tstate = immstruct({})\n}\n\nexport function getState() {\n\treturn state;\n}\n\nexport function getCurrentState() {\n\treturn state.current;\n}","const bindParams = function(fn, ...args) {\n\tconst boundFn = function() {\n\t\t// Call the function\n\t\tconst result = fn.call(fn, ...args);\n\n\t\t// At this point the dependencies are available so copy them (in fact copy every property)\n\t\tObject.assign(boundFn, fn);\n\n\t\treturn result;\n\t};\n\n\treturn boundFn;\n};\n\nexport default bindParams;","import Immutable from 'immutable'\nimport Reflux from 'reflux'\nimport { dereference } from './reference'\n\nconst propertyBind = function(context, ...args) {\n\tlet boundFn = this.bind(context, ...args);\n\tboundFn = Object.assign(boundFn, this);\n\treturn boundFn;\n};\n\nconst getDependencies = (dep) => typeOf(dep) === \"string\" ? [ dep ] : dep.dependencies;\n\nconst provide = function(caller, deps) {\n\tconst isArrayArg = Array.isArray(deps);\n\n\t// If we have passed a value instead of an array then wrap it in an array\n\tif (!isArrayArg) deps = [ deps ];\n\n\t// Resolve the dependencies\n\tconst results = deps.map(dereference);\n\n\t// Set the dependencies on the calling function as a flat combination of dependencies + our keypaths\n\tconst depsIterator = Immutable.fromJS(deps);\n\tcaller.dependencies = depsIterator\n\t\t\t.filter(x => typeof(x) === \"function\")\n\t\t\t.reduce((acc, dep) => acc.add(dep.dependencies)\n\t, depsIterator.filter(x => typeof(x) === \"string\").toSet()).flatten();\n\n\t// Return the result, unwrapping it if the original argument was not an array\n\treturn isArrayArg ? results : results[0];\n};\n\nexport default provide;","import Immutable from 'immutable'\nimport Reflux from 'reflux'\nimport { reference } from './reference'\n\nconst PureStoreMixin = function(storeKey) {\n\t// Don't allow dots in the storeKey or it will confuse our path system\n\tif (storeKey.indexOf(\".\") >= 0)\n\t\tthrow new Error(\"Store keys cannot contain dots\");\n\n\n\treturn {\n\t\tinit() {\n\t\t\t// If no initial state is defined set it to an empty object\n\t\t\tif (!this.getInitialState) this.getInitialState = () => {};\n\n\t\t\t// Construct the object we are going to put in the global state.  We are going to convert the object\n\t\t\t// to an Immutable.js structure.  Note that even if there are already Immutable.js structures in the\n\t\t\t// initial state is doesn't matter.  Store it in the global state with a reference cursor under the\n\t\t\t// storeKey.\n\t\t\treference().cursor().set(storeKey, Immutable.fromJS(this.getInitialState()));\n\n\t\t\t// Create a reference cursor to the state\n\t\t\tthis.cursor = reference(storeKey).cursor;\n\t\t},\n\n\t\t/**\n\t\t * Reset the store data to its initial state\n\t\t */\n\t\tresetToInitialState() {\n\t\t\tthis.update(Immutable.fromJS(this.getInitialState()));\n\t\t},\n\n\t\t/**\n\t\t * A helper method for setting a value on the default cursor.  Equivalent to this.cursor().set(...)\n\t\t *\n\t\t * @param key\n\t\t * @param value\n\t\t * @returns {*}\n\t\t */\n\t\tset(key, value) {\n\t\t\treturn this.cursor().set(key, value);\n\t\t},\n\n\t\t/**\n\t\t * A helper method for getting a value from the default cursor.  Equivalent to this.cursor().get(...)\n\t\t *\n\t\t * @param key\n\t\t * @returns {*}\n\t\t */\n\t\tget(key) {\n\t\t\t// In the event of this returning another cursor we want to dereference it, otherwise it is a real value\n\t\t\tconst result = this.cursor().get(key);\n\t\t\treturn result.deref ? result.deref() : result;\n\t\t},\n\n\t\t/**\n\t\t * A helper method for updating the default cursor.  Equivalent to this.cursor().update(...)\n\t\t *\n\t\t * @param fn\n\t\t * @returns {*}\n\t\t */\n\t\tupdate(fn) {\n\t\t\treturn this.cursor().update(fn);\n\t\t}\n\t}\n};\n\nexport default PureStoreMixin;","import { getState } from '../index'\n\n/**\n * Split a path up into an array that can be used with an immstruct cursor\n *\n * @param keyPath\n */\nconst keyPathToKeyArray = (keyPath) => keyPath ? keyPath.split(\".\") : null;\n\n/**\n * Turn a path or Getter into a real value\n *\n * @param pathOrGetter\n * @returns {*}\n */\n/*const dereference = (pathOrGetter) => {\n\tif (typeof(pathOrGetter) === \"string\") {\n\t\t// TODO: This needs to throw an exception if the path doesn't exist\n\t\treturn getState().cursor(keyPathToKeyArray(pathOrGetter)).deref();\n\t} else if (typeof(pathOrGetter) === \"function\" && pathOrGetter.isPureFluxGetter) {\n\t\treturn pathOrGetter();\n\t} else {\n\t\tthrow new Error(\"Illegal argument type for this Getter\");\n\t}\n};*/\n\nconst dereference = (dependency) => {\n\tif (typeof(dependency) === \"string\") {\n\t\t// TODO: This needs to throw an exception if the path doesn't exist\n\t\treturn getState().cursor(keyPathToKeyArray(dependency)).deref();\n\t} else if (typeof(dependency) === \"function\") {\n\t\treturn dependency();\n\t} else {\n\t\tthrow new Error(\"Illegal argument type for dependency: \" + dependency);\n\t}\n};\n\n/**\n * Get a reference cursor for the given keyPath\n */\nconst reference = (keyPath) => getState().reference(keyPathToKeyArray(keyPath));\n\n/**\n * Get a cursor for the given keyPath\n */\nconst cursor = (keyPath) => getState().cursor(keyPathToKeyArray(keyPath));\n\nexport { dereference, reference, cursor }","import Immutable from 'immutable'\nimport { dereference, reference } from './reference'\n\n/**\n * A React mixin to link state paths or Getters to a React state.\n *\n * @param bindingsFn\n * @returns {{getInitialState: Function, componentDidMount: Function, componentWillUnmount: Function}}\n */\nconst stateBindings = function(bindingsFn) {\n\tif (typeof(bindingsFn) != \"function\")\n\t\tthrow new Error(\"stateBindings needs to take a single function which returns the bindings\");\n\n\tlet bindings, unobservers = Immutable.List();\n\n\treturn {\n\t\tgetInitialState() {\n\t\t\t// Call the binding function to get the bindings (getInitialState should only be called once but put an explicit\n\t\t\t// test just in case).  Call the function in the context of the component.\n\t\t\tif (!bindings) bindings = Immutable.Map(bindingsFn.call(this));\n\n\t\t\t// Calculate and return the bindings\n\t\t\treturn bindings.map(dereference).toObject();\n\t\t},\n\n\t\tcomponentDidMount() {\n\t\t\t// This is a slightly confusing algorithm that gathers up the state properties that need to be updated per\n\t\t\t// path (so that we only need one observer per path).\n\t\t\tlet pathsMap = bindings\n\t\t\t\t\t.map(binding => typeof(binding) === \"string\" ? [ binding ] : binding.dependencies)\n\t\t\t\t\t.reduce((acc, dependencies, stateProperty) => {\n\t\t\t\t\t\tdependencies.forEach(dependency => {\n\t\t\t\t\t\t\tlet set = (acc.get(dependency) || Immutable.Set()).add(stateProperty);\n\t\t\t\t\t\t\tacc = acc.set(dependency, set);\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn acc;\n\t\t\t\t\t}, Immutable.Map());\n\n\t\t\t// Observe each of the keyPaths\n\t\t\t// TODO: Check references are getting garbage collected (might need to use Reference#destroy() in componentWillUnmount)\n\t\t\tunobservers = pathsMap.map((stateProperties, keyPath) => {\n\t\t\t\treturn reference(keyPath).observe(() => {\n\t\t\t\t\t// I want to get a map of stateProperties to values to pass to setState\n\t\t\t\t\tconst newStates = stateProperties.reduce((acc, stateProperty) => {\n\t\t\t\t\t\treturn acc.set(stateProperty, dereference(bindings.get(stateProperty)))\n\t\t\t\t\t}, Immutable.Map());\n\n\t\t\t\t\t// React needs to the top level to be an object\n\t\t\t\t\tthis.setState(newStates.toObject());\n\t\t\t\t});\n\t\t\t}).toList();\n\t\t},\n\n\t\tcomponentWillUnmount() {\n\t\t\t// Stop observing keypaths\n\t\t\tunobservers.forEach(unobserver => unobserver());\n\n\t\t\t// Clear the bindings\n\t\t\tbindings = null;\n\t\t}\n\t};\n\n};\n\nexport default stateBindings"],"sourceRoot":"/source/"}