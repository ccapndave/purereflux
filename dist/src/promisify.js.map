{"version":3,"sources":["promisify.js"],"names":[],"mappings":";;;;;;;;;;yBAAsB,WAAW;;;;2CACY,YAAY;;2BAC7B,aAAa;;AAEzC,IAAM,SAAS,GAAG,mBAAS,EAAE,EAAgB;KAAd,OAAO,gCAAG,EAAE;;AAC1C,KAAI,YAAY,GAAG,IAAI,CAAC;;AAExB,QAAO,UAAI,OAAO,CAAC,UAAS,OAAO,EAAE,MAAM,EAAE;AAC5C,MAAM,YAAY;;;;;;;;;;KAAG,YAAM;;AAE1B,gCATgB,kBAAkB,CASf,KAAK,EAAE,CAAC;;AAE3B,OAAI,MAAM,GAAG,IAAI,CAAC;AAClB,OAAI;AACH,UAAM,GAAG,EAAE,EAAE,CAAC;IACd,CAAC,OAAO,CAAC,EAAE;AACX,WAAO,CAAC,IAAI,uCAAqC,CAAC,CAAG,CAAC;IACtD;;AAED,eAAY,GAAG,6BAlBC,kBAAkB,CAkBA,GAAG,EAAE,CAAC;;;;AAIxC,OAAI,YAAY,CAAC,IAAI,CAAC,UAAA,UAAU;WAAI,aArB9B,WAAW,CAqB+B,UAAU,CAAC,OAAO,EAAE,CAAC,IAAI,IAAI;IAAA,CAAC,EAAE;AAC/E,iCAvBK,QAAQ,EAuBH,CAAC,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;IACtC,MAAM;;AAEN,WAAO,CAAC,MAAM,CAAC,CAAC;IAChB;GACD,CAAA,CAAC;;;AAGF,YAAU,CAAC,YAAM;AAChB,gCAhCM,QAAQ,EAgCJ,CAAC,cAAc,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;AAChD,SAAM,CAAC,2DAA2D,GAAG,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC;GAC9F,EAAE,OAAO,GAAG,IAAI,CAAC,CAAC;;AAEnB,cAAY,EAAE,CAAC;EACf,CAAC,CAAC;CACH,CAAC;;qBAEa,SAAS","file":"promisify.js","sourcesContent":["import Immutable from 'immutable'\nimport { getState, _dependencyTracker } from './appState'\nimport { dereference } from './reference'\n\nconst promisify = function(fn, timeout = 10) {\n\tlet dependencies = null;\n\n\treturn new Promise(function(resolve, reject) {\n\t\tconst tryToResolve = () => {\n\t\t\t// Run the function, watching any dependencies TODO: it might not be necessary to continuously re-run fn\n\t\t\t_dependencyTracker.start();\n\n\t\t\tlet result = null;\n\t\t\ttry {\n\t\t\t\tresult = fn();\n\t\t\t} catch (e) {\n\t\t\t\tconsole.info(`Ignoring exception in promisify: ${e}`);\n\t\t\t}\n\n\t\t\tdependencies = _dependencyTracker.end();\n\n\t\t\t// If any dependencies are null then watch for the next change\n\t\t\t// TODO: this is bad; we only want to do stuff if the particular dependencies have changed\n\t\t\tif (dependencies.some(dependency => dereference(dependency.toArray()) == null)) {\n\t\t\t\tgetState().once(\"swap\", tryToResolve);\n\t\t\t} else {\n\t\t\t\t// Otherwise we can resolve the promise\n\t\t\t\tresolve(result);\n\t\t\t}\n\t\t};\n\n\t\t// If the timeout is exceeded without the promise resolving then remove the listener and reject the promise\n\t\tsetTimeout(() => {\n\t\t\tgetState().removeListener(\"swap\", tryToResolve);\n\t\t\treject(\"Promisify timed out waiting for dependencies to resolve: \" + dependencies.toString());\n\t\t}, timeout * 1000);\n\n\t\ttryToResolve();\n\t});\n};\n\nexport default promisify\n"],"sourceRoot":"/source/"}