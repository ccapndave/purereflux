{"version":3,"sources":["streamify.js"],"names":[],"mappings":";;;;;;;;;;;;yBAAsB,WAAW;;;;2CACY,YAAY;;2BAC7B,aAAa;;kBAC1B,IAAI;;;;AAEnB,IAAM,SAAS,GAAG,mBAAS,EAAE,EAAE;AAC9B,KAAI,YAAY,GAAG,IAAI,CAAC;;;AAGxB,KAAM,WAAW,GAAG,uBAAM;AACzB,+BATiB,kBAAkB,CAShB,KAAK,EAAE,CAAC;AAC3B,MAAI,MAAM,GAAG,IAAI,CAAC;AAClB,MAAI;AACH,SAAM,GAAG,EAAE,EAAE,CAAC;GACd,CAAC,OAAO,CAAC,EAAE;AACX,UAAO,CAAC,IAAI,uCAAqC,CAAC,CAAG,CAAC;GACtD;AACD,cAAY,GAAG,6BAhBE,kBAAkB,CAgBD,GAAG,EAAE,CAAC;AACxC,SAAO,MAAM,CAAC;EACd,CAAC;;;;;;;;AAQF,KAAM,sBAAsB,GAAG,gCAAC,OAAO,EAAE,YAAY,EAAK;AACzD,SAAO,YAAY,CAAC,MAAM,CAAC,UAAA,IAAI,EAAI;AAClC,OAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;AACxD,UAAO,uBAAU,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,aAAa,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC,CAAC;GACnF,CAAC,CAAC,KAAK,EAAE,CAAC,OAAO,EAAE,CAAC;EACrB,CAAC;;AAEF,QAAO,gBAAG,UAAU;;AAAA,EAElB,SAAS,CAAC,6BAnCJ,QAAQ,EAmCM,EAAE,MAAM,EAAE;;;MAAG,QAAQ;MAAE,QAAQ;MAAE,OAAO;SAAQ,EAAE,QAAQ,EAAR,QAAQ,EAAE,QAAQ,EAAR,QAAQ,EAAE,OAAO,EAAP,OAAO,EAAE;EAAC,CAAC;;;EAGrG,MAAM,CAAC;MAAG,OAAO,SAAP,OAAO;SAAO,YAAY,KAAK,IAAI,IAAI,sBAAsB,CAAC,uBAAU,IAAI,CAAC,OAAO,CAAC,EAAE,YAAY,CAAC,CAAC,IAAI,GAAG,CAAC;EAAA,CAAC;;;EAGxH,GAAG,CAAC,WAAW,CAAC,CAAC;CACnB,CAAC;;qBAEa,SAAS","file":"streamify.js","sourcesContent":["import Immutable from 'immutable'\nimport { getState, _dependencyTracker } from './appState'\nimport { dereference } from './reference'\nimport Rx from 'rx'\n\nconst streamify = function(fn) {\n\tlet dependencies = null;\n\n\t/* Run the function, tracking the dependencies and returning the result */\n\tconst runFunction = () => {\n\t\t_dependencyTracker.start();\n\t\tlet result = null;\n\t\ttry {\n\t\t\tresult = fn();\n\t\t} catch (e) {\n\t\t\tconsole.info(`Ignoring exception in promisify: ${e}`);\n\t\t}\n\t\tdependencies = _dependencyTracker.end();\n\t\treturn result;\n\t};\n\n\t/**\n\t * A binding is considered to have changed if its keyPath contains the swapped keyPath.\n\t * So ['a', 'b', 'c'] would be changed by a change to ['a'], ['a', 'b'] or ['a', 'b', 'c'].\n\t * Note that it would also be changed by any deeper change, for example ['a', 'b', 'c', 'd'].\n\t * Convert it to a set after the computation since we don't care about duplicates.\n\t */\n\tconst getChangedDependencies = (keyPath, dependencies) => {\n\t\treturn dependencies.filter(path => {\n\t\t\tconst compareLength = Math.min(path.size, keyPath.size);\n\t\t\treturn Immutable.is(keyPath.slice(0, compareLength), path.slice(0, compareLength));\n\t\t}).toSet().flatten();\n\t};\n\n\treturn Rx.Observable\n\t\t// Turn swap events on the global state into a stream, and put the arguments into a single object\n\t\t.fromEvent(getState(), \"swap\", ([ newState, oldState, keyPath ]) => ({ newState, oldState, keyPath }))\n\n\t\t// We only care about swaps where the keyPaths are in the dependency list, or the first call (when dependencies is still null)\n\t\t.filter(({ keyPath }) => dependencies === null || getChangedDependencies(Immutable.List(keyPath), dependencies).size > 0)\n\n\t\t// Run the function and pass the result on\n\t\t.map(runFunction);\n};\n\nexport default streamify\n"],"sourceRoot":"/source/"}