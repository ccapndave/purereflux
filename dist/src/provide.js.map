{"version":3,"sources":["provide.js"],"names":[],"mappings":";;;;;;IAAO,SAAS,wCAAM,WAAW;;IAC1B,MAAM,wCAAM,QAAQ;;IAClB,WAAW,WAAQ,aAAa,EAAhC,WAAW;;AAEpB,IAAM,YAAY,GAAG,sBAAS,OAAO,EAAW;;;mCAAN,IAAI;AAAJ,MAAI;;;AAC7C,KAAI,OAAO,GAAG,QAAA,IAAI,EAAC,IAAI,MAAA,QAAC,OAAO,SAAK,IAAI,EAAC,CAAC;AAC1C,QAAO,GAAG,MAAA,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AACvC,QAAO,OAAO,CAAC;CACf,CAAC;;AAEF,IAAM,eAAe,GAAG,UAAC,GAAG;QAAK,MAAM,CAAC,GAAG,CAAC,KAAK,QAAQ,GAAG,CAAE,GAAG,CAAE,GAAG,GAAG,CAAC,YAAY;CAAA,CAAC;;AAEvF,IAAM,OAAO,GAAG,iBAAS,MAAM,EAAE,IAAI,EAAE;AACtC,KAAM,UAAU,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;;;AAGvC,KAAI,CAAC,UAAU,EAAE,IAAI,GAAG,CAAE,IAAI,CAAE,CAAC;;;AAGjC,KAAM,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;;;AAGtC,KAAM,YAAY,GAAG,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAC5C,OAAM,CAAC,YAAY,GAAG,YAAY,CAC/B,MAAM,CAAC,UAAA,CAAC;SAAI,OAAO,CAAC,AAAC,KAAK,UAAU;EAAA,CAAC,CACrC,MAAM,CAAC,UAAC,GAAG,EAAE,GAAG;SAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC;EAAA,EAC/C,YAAY,CAAC,MAAM,CAAC,UAAA,CAAC;SAAI,OAAO,CAAC,AAAC,KAAK,QAAQ;EAAA,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC;;;AAGtE,QAAO,UAAU,GAAG,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;CACzC,CAAC;;iBAEa,OAAO","file":"provide.js","sourcesContent":["import Immutable from 'immutable'\nimport Reflux from 'reflux'\nimport { dereference } from './reference'\n\nconst propertyBind = function(context, ...args) {\n\tlet boundFn = this.bind(context, ...args);\n\tboundFn = Object.assign(boundFn, this);\n\treturn boundFn;\n};\n\nconst getDependencies = (dep) => typeOf(dep) === \"string\" ? [ dep ] : dep.dependencies;\n\nconst provide = function(caller, deps) {\n\tconst isArrayArg = Array.isArray(deps);\n\n\t// If we have passed a value instead of an array then wrap it in an array\n\tif (!isArrayArg) deps = [ deps ];\n\n\t// Resolve the dependencies\n\tconst results = deps.map(dereference);\n\n\t// Set the dependencies on the calling function as a flat combination of dependencies + our keypaths\n\tconst depsIterator = Immutable.fromJS(deps);\n\tcaller.dependencies = depsIterator\n\t\t\t.filter(x => typeof(x) === \"function\")\n\t\t\t.reduce((acc, dep) => acc.add(dep.dependencies)\n\t, depsIterator.filter(x => typeof(x) === \"string\").toSet()).flatten();\n\n\t// Return the result, unwrapping it if the original argument was not an array\n\treturn isArrayArg ? results : results[0];\n};\n\nexport default provide;"],"sourceRoot":"/source/"}